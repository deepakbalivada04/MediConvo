import { GoogleGenAI, Modality } from "@google/genai";
import { ConsultationRecord, ChatMessage } from "../types";
import { decode, decodeAudioData, audioContext } from "./audioUtils";

// Support both standard process.env (Cloud/Node) and Vite's import.meta.env (Local Dev)
const apiKey = process.env.API_KEY || (import.meta as any).env?.VITE_API_KEY || '';

const ai = new GoogleGenAI({ apiKey });

// 1. Summarization using gemini-2.5-flash
export async function generateSummary(transcript: ChatMessage[]): Promise<string> {
  if (!apiKey) throw new Error("API Key missing");

  const conversationText = transcript
    .map(msg => `${msg.role.toUpperCase()}: ${msg.text}`)
    .join('\n');

  const prompt = `
    You are a professional medical scribe assistant. Summarize the following doctor-patient consultation.
    Your output MUST start with "Chief Complaint:" and follow the structure below exactly.
    If any section cannot be determined, state "None specified."

    Format the summary into structured sections: 
    - Chief Complaint
    - Key Symptoms
    - Diagnosis (if mentioned)
    - Treatment Plan / Recommendations
    
    Conversation:
    ${conversationText}
  `;
  
  const MAX_RETRIES = 3;
  let lastError: any = null;

  // Added a retry loop to improve resilience against transient network/API errors
  for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
      try {
          const response = await ai.models.generateContent({
              model: 'gemini-2.5-flash',
              contents: prompt,
              // Adding a short timeout to handle hanging requests
              config: {
                  timeout: 10000, // 10 seconds
              }
          });

          // If successful and text exists, return it
          if (response.text) {
              return response.text;
          }
          
          // If response is successful but empty, treat as an internal model failure
          return "No summary generated by the model.";

      } catch (error) {
          lastError = error;
          console.warn(`Summary generation attempt ${attempt} failed. Retrying...`, error);
          if (attempt === MAX_RETRIES) {
              console.error("Final summary error after all retries:", lastError);
              // Ensure the original error is propagated if needed, but return the required string for UI
              return "Failed to generate summary.";
          }
          // Simple delay before retrying
          await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
      }
  }

  // Fallback return (should only be reached if retries fail)
  return "Failed to generate summary.";
}

// 2. TTS using gemini-2.5-flash-preview-tts
export async function playTextToSpeech(text: string, language: string) {
  if (!apiKey) return;
  
  // Select a voice based on language roughly (though the model is multilingual, voice config helps)
  const voiceName = 'Kore'; 

  try {
    const response = await ai.models.generateContent({
      model: "gemini-2.5-flash-preview-tts",
      contents: [{ parts: [{ text: `Say in ${language}: ${text}` }] }],
      config: {
        responseModalities: [Modality.AUDIO],
        speechConfig: {
          voiceConfig: {
            prebuiltVoiceConfig: { voiceName },
          },
        },
      },
    });

    const base64Audio = response.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
    if (base64Audio) {
      const audioBuffer = await decodeAudioData(
        decode(base64Audio),
        audioContext,
        24000,
        1
      );
      const source = audioContext.createBufferSource();
      source.buffer = audioBuffer;
      source.connect(audioContext.destination);
      source.start();
    }
  } catch (error) {
    console.error("TTS error:", error);
  }
}

// 3. Audio Note Transcription using gemini-2.5-flash
export async function transcribeAudioNote(base64Audio: string, mimeType: string): Promise<string> {
  if (!apiKey) throw new Error("API Key missing");

  try {
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: {
        parts: [
          { inlineData: { data: base64Audio, mimeType: mimeType } },
          { text: "Transcribe this medical audio note verbatim." }
        ]
      }
    });
    return response.text || "";
  } catch (error) {
    console.error("Transcription error:", error);
    throw error;
  }
}